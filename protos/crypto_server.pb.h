// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: crypto_server.proto

#ifndef PROTOBUF_crypto_5fserver_2eproto__INCLUDED
#define PROTOBUF_crypto_5fserver_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace crypto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_crypto_5fserver_2eproto();
void protobuf_AssignDesc_crypto_5fserver_2eproto();
void protobuf_ShutdownFile_crypto_5fserver_2eproto();

class CbcDecryptFileRequest;
class CbcDecryptFileResponse;
class CbcEncryptFileRequest;
class CbcEncryptFileResponse;
class CreateCbcKeyRequest;
class CreateCbcKeyResponse;
class CreateKeyPairRequest;
class CreateKeyPairResponse;
class PrivateKeyDecryptRequest;
class PrivateKeyDecryptResponse;
class PublicKeyEncryptRequest;
class PublicKeyEncryptResponse;

enum SymmetricKeyBits {
  SymmetricKeyBitsUnknown = 0,
  SymmetricKey128Bits = 128,
  SymmetricKey256Bits = 256,
  SymmetricKeyBits_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SymmetricKeyBits_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SymmetricKeyBits_IsValid(int value);
const SymmetricKeyBits SymmetricKeyBits_MIN = SymmetricKeyBitsUnknown;
const SymmetricKeyBits SymmetricKeyBits_MAX = SymmetricKey256Bits;
const int SymmetricKeyBits_ARRAYSIZE = SymmetricKeyBits_MAX + 1;

const ::google::protobuf::EnumDescriptor* SymmetricKeyBits_descriptor();
inline const ::std::string& SymmetricKeyBits_Name(SymmetricKeyBits value) {
  return ::google::protobuf::internal::NameOfEnum(
    SymmetricKeyBits_descriptor(), value);
}
inline bool SymmetricKeyBits_Parse(
    const ::std::string& name, SymmetricKeyBits* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SymmetricKeyBits>(
    SymmetricKeyBits_descriptor(), name, value);
}
enum AsymmetricType {
  AsymmetricTypeUnknown = 0,
  SM2 = 1,
  RSA = 2,
  AsymmetricType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AsymmetricType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AsymmetricType_IsValid(int value);
const AsymmetricType AsymmetricType_MIN = AsymmetricTypeUnknown;
const AsymmetricType AsymmetricType_MAX = RSA;
const int AsymmetricType_ARRAYSIZE = AsymmetricType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AsymmetricType_descriptor();
inline const ::std::string& AsymmetricType_Name(AsymmetricType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AsymmetricType_descriptor(), value);
}
inline bool AsymmetricType_Parse(
    const ::std::string& name, AsymmetricType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AsymmetricType>(
    AsymmetricType_descriptor(), name, value);
}
enum AsymmetricKeyBits {
  KeyBitsUnknown = 0,
  KEY192BITS = 192,
  KEY256BITS = 256,
  KEY1024BITS = 1024,
  AsymmetricKeyBits_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AsymmetricKeyBits_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AsymmetricKeyBits_IsValid(int value);
const AsymmetricKeyBits AsymmetricKeyBits_MIN = KeyBitsUnknown;
const AsymmetricKeyBits AsymmetricKeyBits_MAX = KEY1024BITS;
const int AsymmetricKeyBits_ARRAYSIZE = AsymmetricKeyBits_MAX + 1;

const ::google::protobuf::EnumDescriptor* AsymmetricKeyBits_descriptor();
inline const ::std::string& AsymmetricKeyBits_Name(AsymmetricKeyBits value) {
  return ::google::protobuf::internal::NameOfEnum(
    AsymmetricKeyBits_descriptor(), value);
}
inline bool AsymmetricKeyBits_Parse(
    const ::std::string& name, AsymmetricKeyBits* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AsymmetricKeyBits>(
    AsymmetricKeyBits_descriptor(), name, value);
}
// ===================================================================

class CreateCbcKeyRequest : public ::google::protobuf::Message {
 public:
  CreateCbcKeyRequest();
  virtual ~CreateCbcKeyRequest();

  CreateCbcKeyRequest(const CreateCbcKeyRequest& from);

  inline CreateCbcKeyRequest& operator=(const CreateCbcKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateCbcKeyRequest& default_instance();

  void Swap(CreateCbcKeyRequest* other);

  // implements Message ----------------------------------------------

  inline CreateCbcKeyRequest* New() const { return New(NULL); }

  CreateCbcKeyRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateCbcKeyRequest& from);
  void MergeFrom(const CreateCbcKeyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateCbcKeyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .crypto.SymmetricKeyBits key_bits = 1;
  void clear_key_bits();
  static const int kKeyBitsFieldNumber = 1;
  ::crypto::SymmetricKeyBits key_bits() const;
  void set_key_bits(::crypto::SymmetricKeyBits value);

  // @@protoc_insertion_point(class_scope:crypto.CreateCbcKeyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int key_bits_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static CreateCbcKeyRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateCbcKeyResponse : public ::google::protobuf::Message {
 public:
  CreateCbcKeyResponse();
  virtual ~CreateCbcKeyResponse();

  CreateCbcKeyResponse(const CreateCbcKeyResponse& from);

  inline CreateCbcKeyResponse& operator=(const CreateCbcKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateCbcKeyResponse& default_instance();

  void Swap(CreateCbcKeyResponse* other);

  // implements Message ----------------------------------------------

  inline CreateCbcKeyResponse* New() const { return New(NULL); }

  CreateCbcKeyResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateCbcKeyResponse& from);
  void MergeFrom(const CreateCbcKeyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateCbcKeyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:crypto.CreateCbcKeyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static CreateCbcKeyResponse* default_instance_;
};
// -------------------------------------------------------------------

class CbcEncryptFileRequest : public ::google::protobuf::Message {
 public:
  CbcEncryptFileRequest();
  virtual ~CbcEncryptFileRequest();

  CbcEncryptFileRequest(const CbcEncryptFileRequest& from);

  inline CbcEncryptFileRequest& operator=(const CbcEncryptFileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CbcEncryptFileRequest& default_instance();

  void Swap(CbcEncryptFileRequest* other);

  // implements Message ----------------------------------------------

  inline CbcEncryptFileRequest* New() const { return New(NULL); }

  CbcEncryptFileRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CbcEncryptFileRequest& from);
  void MergeFrom(const CbcEncryptFileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CbcEncryptFileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string iv = 2;
  void clear_iv();
  static const int kIvFieldNumber = 2;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  void set_iv(const char* value);
  void set_iv(const char* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional string file_path = 3;
  void clear_file_path();
  static const int kFilePathFieldNumber = 3;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:crypto.CbcEncryptFileRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static CbcEncryptFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class CbcEncryptFileResponse : public ::google::protobuf::Message {
 public:
  CbcEncryptFileResponse();
  virtual ~CbcEncryptFileResponse();

  CbcEncryptFileResponse(const CbcEncryptFileResponse& from);

  inline CbcEncryptFileResponse& operator=(const CbcEncryptFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CbcEncryptFileResponse& default_instance();

  void Swap(CbcEncryptFileResponse* other);

  // implements Message ----------------------------------------------

  inline CbcEncryptFileResponse* New() const { return New(NULL); }

  CbcEncryptFileResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CbcEncryptFileResponse& from);
  void MergeFrom(const CbcEncryptFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CbcEncryptFileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:crypto.CbcEncryptFileResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static CbcEncryptFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CbcDecryptFileRequest : public ::google::protobuf::Message {
 public:
  CbcDecryptFileRequest();
  virtual ~CbcDecryptFileRequest();

  CbcDecryptFileRequest(const CbcDecryptFileRequest& from);

  inline CbcDecryptFileRequest& operator=(const CbcDecryptFileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CbcDecryptFileRequest& default_instance();

  void Swap(CbcDecryptFileRequest* other);

  // implements Message ----------------------------------------------

  inline CbcDecryptFileRequest* New() const { return New(NULL); }

  CbcDecryptFileRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CbcDecryptFileRequest& from);
  void MergeFrom(const CbcDecryptFileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CbcDecryptFileRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string iv = 2;
  void clear_iv();
  static const int kIvFieldNumber = 2;
  const ::std::string& iv() const;
  void set_iv(const ::std::string& value);
  void set_iv(const char* value);
  void set_iv(const char* value, size_t size);
  ::std::string* mutable_iv();
  ::std::string* release_iv();
  void set_allocated_iv(::std::string* iv);

  // optional string file_path = 3;
  void clear_file_path();
  static const int kFilePathFieldNumber = 3;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:crypto.CbcDecryptFileRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr iv_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static CbcDecryptFileRequest* default_instance_;
};
// -------------------------------------------------------------------

class CbcDecryptFileResponse : public ::google::protobuf::Message {
 public:
  CbcDecryptFileResponse();
  virtual ~CbcDecryptFileResponse();

  CbcDecryptFileResponse(const CbcDecryptFileResponse& from);

  inline CbcDecryptFileResponse& operator=(const CbcDecryptFileResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CbcDecryptFileResponse& default_instance();

  void Swap(CbcDecryptFileResponse* other);

  // implements Message ----------------------------------------------

  inline CbcDecryptFileResponse* New() const { return New(NULL); }

  CbcDecryptFileResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CbcDecryptFileResponse& from);
  void MergeFrom(const CbcDecryptFileResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CbcDecryptFileResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:crypto.CbcDecryptFileResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static CbcDecryptFileResponse* default_instance_;
};
// -------------------------------------------------------------------

class CreateKeyPairRequest : public ::google::protobuf::Message {
 public:
  CreateKeyPairRequest();
  virtual ~CreateKeyPairRequest();

  CreateKeyPairRequest(const CreateKeyPairRequest& from);

  inline CreateKeyPairRequest& operator=(const CreateKeyPairRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateKeyPairRequest& default_instance();

  void Swap(CreateKeyPairRequest* other);

  // implements Message ----------------------------------------------

  inline CreateKeyPairRequest* New() const { return New(NULL); }

  CreateKeyPairRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateKeyPairRequest& from);
  void MergeFrom(const CreateKeyPairRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateKeyPairRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .crypto.AsymmetricType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::crypto::AsymmetricType type() const;
  void set_type(::crypto::AsymmetricType value);

  // optional .crypto.AsymmetricKeyBits key_bits = 2;
  void clear_key_bits();
  static const int kKeyBitsFieldNumber = 2;
  ::crypto::AsymmetricKeyBits key_bits() const;
  void set_key_bits(::crypto::AsymmetricKeyBits value);

  // @@protoc_insertion_point(class_scope:crypto.CreateKeyPairRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  int key_bits_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static CreateKeyPairRequest* default_instance_;
};
// -------------------------------------------------------------------

class CreateKeyPairResponse : public ::google::protobuf::Message {
 public:
  CreateKeyPairResponse();
  virtual ~CreateKeyPairResponse();

  CreateKeyPairResponse(const CreateKeyPairResponse& from);

  inline CreateKeyPairResponse& operator=(const CreateKeyPairResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateKeyPairResponse& default_instance();

  void Swap(CreateKeyPairResponse* other);

  // implements Message ----------------------------------------------

  inline CreateKeyPairResponse* New() const { return New(NULL); }

  CreateKeyPairResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateKeyPairResponse& from);
  void MergeFrom(const CreateKeyPairResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CreateKeyPairResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string public_key = 2;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional string private_key = 3;
  void clear_private_key();
  static const int kPrivateKeyFieldNumber = 3;
  const ::std::string& private_key() const;
  void set_private_key(const ::std::string& value);
  void set_private_key(const char* value);
  void set_private_key(const char* value, size_t size);
  ::std::string* mutable_private_key();
  ::std::string* release_private_key();
  void set_allocated_private_key(::std::string* private_key);

  // @@protoc_insertion_point(class_scope:crypto.CreateKeyPairResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr private_key_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static CreateKeyPairResponse* default_instance_;
};
// -------------------------------------------------------------------

class PublicKeyEncryptRequest : public ::google::protobuf::Message {
 public:
  PublicKeyEncryptRequest();
  virtual ~PublicKeyEncryptRequest();

  PublicKeyEncryptRequest(const PublicKeyEncryptRequest& from);

  inline PublicKeyEncryptRequest& operator=(const PublicKeyEncryptRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicKeyEncryptRequest& default_instance();

  void Swap(PublicKeyEncryptRequest* other);

  // implements Message ----------------------------------------------

  inline PublicKeyEncryptRequest* New() const { return New(NULL); }

  PublicKeyEncryptRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicKeyEncryptRequest& from);
  void MergeFrom(const PublicKeyEncryptRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicKeyEncryptRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .crypto.AsymmetricType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::crypto::AsymmetricType type() const;
  void set_type(::crypto::AsymmetricType value);

  // optional string public_key = 2;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 2;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  void set_public_key(const char* value);
  void set_public_key(const char* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // optional string plaintext = 3;
  void clear_plaintext();
  static const int kPlaintextFieldNumber = 3;
  const ::std::string& plaintext() const;
  void set_plaintext(const ::std::string& value);
  void set_plaintext(const char* value);
  void set_plaintext(const char* value, size_t size);
  ::std::string* mutable_plaintext();
  ::std::string* release_plaintext();
  void set_allocated_plaintext(::std::string* plaintext);

  // @@protoc_insertion_point(class_scope:crypto.PublicKeyEncryptRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr plaintext_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static PublicKeyEncryptRequest* default_instance_;
};
// -------------------------------------------------------------------

class PublicKeyEncryptResponse : public ::google::protobuf::Message {
 public:
  PublicKeyEncryptResponse();
  virtual ~PublicKeyEncryptResponse();

  PublicKeyEncryptResponse(const PublicKeyEncryptResponse& from);

  inline PublicKeyEncryptResponse& operator=(const PublicKeyEncryptResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicKeyEncryptResponse& default_instance();

  void Swap(PublicKeyEncryptResponse* other);

  // implements Message ----------------------------------------------

  inline PublicKeyEncryptResponse* New() const { return New(NULL); }

  PublicKeyEncryptResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PublicKeyEncryptResponse& from);
  void MergeFrom(const PublicKeyEncryptResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PublicKeyEncryptResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cipher = 2;
  void clear_cipher();
  static const int kCipherFieldNumber = 2;
  const ::std::string& cipher() const;
  void set_cipher(const ::std::string& value);
  void set_cipher(const char* value);
  void set_cipher(const char* value, size_t size);
  ::std::string* mutable_cipher();
  ::std::string* release_cipher();
  void set_allocated_cipher(::std::string* cipher);

  // @@protoc_insertion_point(class_scope:crypto.PublicKeyEncryptResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr cipher_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static PublicKeyEncryptResponse* default_instance_;
};
// -------------------------------------------------------------------

class PrivateKeyDecryptRequest : public ::google::protobuf::Message {
 public:
  PrivateKeyDecryptRequest();
  virtual ~PrivateKeyDecryptRequest();

  PrivateKeyDecryptRequest(const PrivateKeyDecryptRequest& from);

  inline PrivateKeyDecryptRequest& operator=(const PrivateKeyDecryptRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateKeyDecryptRequest& default_instance();

  void Swap(PrivateKeyDecryptRequest* other);

  // implements Message ----------------------------------------------

  inline PrivateKeyDecryptRequest* New() const { return New(NULL); }

  PrivateKeyDecryptRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrivateKeyDecryptRequest& from);
  void MergeFrom(const PrivateKeyDecryptRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateKeyDecryptRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .crypto.AsymmetricType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::crypto::AsymmetricType type() const;
  void set_type(::crypto::AsymmetricType value);

  // optional string private_key = 2;
  void clear_private_key();
  static const int kPrivateKeyFieldNumber = 2;
  const ::std::string& private_key() const;
  void set_private_key(const ::std::string& value);
  void set_private_key(const char* value);
  void set_private_key(const char* value, size_t size);
  ::std::string* mutable_private_key();
  ::std::string* release_private_key();
  void set_allocated_private_key(::std::string* private_key);

  // optional string cipher = 3;
  void clear_cipher();
  static const int kCipherFieldNumber = 3;
  const ::std::string& cipher() const;
  void set_cipher(const ::std::string& value);
  void set_cipher(const char* value);
  void set_cipher(const char* value, size_t size);
  ::std::string* mutable_cipher();
  ::std::string* release_cipher();
  void set_allocated_cipher(::std::string* cipher);

  // @@protoc_insertion_point(class_scope:crypto.PrivateKeyDecryptRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr private_key_;
  ::google::protobuf::internal::ArenaStringPtr cipher_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static PrivateKeyDecryptRequest* default_instance_;
};
// -------------------------------------------------------------------

class PrivateKeyDecryptResponse : public ::google::protobuf::Message {
 public:
  PrivateKeyDecryptResponse();
  virtual ~PrivateKeyDecryptResponse();

  PrivateKeyDecryptResponse(const PrivateKeyDecryptResponse& from);

  inline PrivateKeyDecryptResponse& operator=(const PrivateKeyDecryptResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PrivateKeyDecryptResponse& default_instance();

  void Swap(PrivateKeyDecryptResponse* other);

  // implements Message ----------------------------------------------

  inline PrivateKeyDecryptResponse* New() const { return New(NULL); }

  PrivateKeyDecryptResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PrivateKeyDecryptResponse& from);
  void MergeFrom(const PrivateKeyDecryptResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PrivateKeyDecryptResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string plaintext = 2;
  void clear_plaintext();
  static const int kPlaintextFieldNumber = 2;
  const ::std::string& plaintext() const;
  void set_plaintext(const ::std::string& value);
  void set_plaintext(const char* value);
  void set_plaintext(const char* value, size_t size);
  ::std::string* mutable_plaintext();
  ::std::string* release_plaintext();
  void set_allocated_plaintext(::std::string* plaintext);

  // @@protoc_insertion_point(class_scope:crypto.PrivateKeyDecryptResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr plaintext_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_crypto_5fserver_2eproto();
  friend void protobuf_AssignDesc_crypto_5fserver_2eproto();
  friend void protobuf_ShutdownFile_crypto_5fserver_2eproto();

  void InitAsDefaultInstance();
  static PrivateKeyDecryptResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// CreateCbcKeyRequest

// optional .crypto.SymmetricKeyBits key_bits = 1;
inline void CreateCbcKeyRequest::clear_key_bits() {
  key_bits_ = 0;
}
inline ::crypto::SymmetricKeyBits CreateCbcKeyRequest::key_bits() const {
  // @@protoc_insertion_point(field_get:crypto.CreateCbcKeyRequest.key_bits)
  return static_cast< ::crypto::SymmetricKeyBits >(key_bits_);
}
inline void CreateCbcKeyRequest::set_key_bits(::crypto::SymmetricKeyBits value) {
  
  key_bits_ = value;
  // @@protoc_insertion_point(field_set:crypto.CreateCbcKeyRequest.key_bits)
}

// -------------------------------------------------------------------

// CreateCbcKeyResponse

// optional string key = 1;
inline void CreateCbcKeyResponse::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateCbcKeyResponse::key() const {
  // @@protoc_insertion_point(field_get:crypto.CreateCbcKeyResponse.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateCbcKeyResponse::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CreateCbcKeyResponse.key)
}
inline void CreateCbcKeyResponse::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CreateCbcKeyResponse.key)
}
inline void CreateCbcKeyResponse::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CreateCbcKeyResponse.key)
}
inline ::std::string* CreateCbcKeyResponse::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CreateCbcKeyResponse.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateCbcKeyResponse::release_key() {
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateCbcKeyResponse::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:crypto.CreateCbcKeyResponse.key)
}

// -------------------------------------------------------------------

// CbcEncryptFileRequest

// optional string key = 1;
inline void CbcEncryptFileRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CbcEncryptFileRequest::key() const {
  // @@protoc_insertion_point(field_get:crypto.CbcEncryptFileRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcEncryptFileRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CbcEncryptFileRequest.key)
}
inline void CbcEncryptFileRequest::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CbcEncryptFileRequest.key)
}
inline void CbcEncryptFileRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CbcEncryptFileRequest.key)
}
inline ::std::string* CbcEncryptFileRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CbcEncryptFileRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CbcEncryptFileRequest::release_key() {
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcEncryptFileRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:crypto.CbcEncryptFileRequest.key)
}

// optional string iv = 2;
inline void CbcEncryptFileRequest::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CbcEncryptFileRequest::iv() const {
  // @@protoc_insertion_point(field_get:crypto.CbcEncryptFileRequest.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcEncryptFileRequest::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CbcEncryptFileRequest.iv)
}
inline void CbcEncryptFileRequest::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CbcEncryptFileRequest.iv)
}
inline void CbcEncryptFileRequest::set_iv(const char* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CbcEncryptFileRequest.iv)
}
inline ::std::string* CbcEncryptFileRequest::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CbcEncryptFileRequest.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CbcEncryptFileRequest::release_iv() {
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcEncryptFileRequest::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:crypto.CbcEncryptFileRequest.iv)
}

// optional string file_path = 3;
inline void CbcEncryptFileRequest::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CbcEncryptFileRequest::file_path() const {
  // @@protoc_insertion_point(field_get:crypto.CbcEncryptFileRequest.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcEncryptFileRequest::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CbcEncryptFileRequest.file_path)
}
inline void CbcEncryptFileRequest::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CbcEncryptFileRequest.file_path)
}
inline void CbcEncryptFileRequest::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CbcEncryptFileRequest.file_path)
}
inline ::std::string* CbcEncryptFileRequest::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CbcEncryptFileRequest.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CbcEncryptFileRequest::release_file_path() {
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcEncryptFileRequest::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:crypto.CbcEncryptFileRequest.file_path)
}

// -------------------------------------------------------------------

// CbcEncryptFileResponse

// -------------------------------------------------------------------

// CbcDecryptFileRequest

// optional string key = 1;
inline void CbcDecryptFileRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CbcDecryptFileRequest::key() const {
  // @@protoc_insertion_point(field_get:crypto.CbcDecryptFileRequest.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcDecryptFileRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CbcDecryptFileRequest.key)
}
inline void CbcDecryptFileRequest::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CbcDecryptFileRequest.key)
}
inline void CbcDecryptFileRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CbcDecryptFileRequest.key)
}
inline ::std::string* CbcDecryptFileRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CbcDecryptFileRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CbcDecryptFileRequest::release_key() {
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcDecryptFileRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:crypto.CbcDecryptFileRequest.key)
}

// optional string iv = 2;
inline void CbcDecryptFileRequest::clear_iv() {
  iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CbcDecryptFileRequest::iv() const {
  // @@protoc_insertion_point(field_get:crypto.CbcDecryptFileRequest.iv)
  return iv_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcDecryptFileRequest::set_iv(const ::std::string& value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CbcDecryptFileRequest.iv)
}
inline void CbcDecryptFileRequest::set_iv(const char* value) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CbcDecryptFileRequest.iv)
}
inline void CbcDecryptFileRequest::set_iv(const char* value, size_t size) {
  
  iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CbcDecryptFileRequest.iv)
}
inline ::std::string* CbcDecryptFileRequest::mutable_iv() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CbcDecryptFileRequest.iv)
  return iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CbcDecryptFileRequest::release_iv() {
  
  return iv_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcDecryptFileRequest::set_allocated_iv(::std::string* iv) {
  if (iv != NULL) {
    
  } else {
    
  }
  iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), iv);
  // @@protoc_insertion_point(field_set_allocated:crypto.CbcDecryptFileRequest.iv)
}

// optional string file_path = 3;
inline void CbcDecryptFileRequest::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CbcDecryptFileRequest::file_path() const {
  // @@protoc_insertion_point(field_get:crypto.CbcDecryptFileRequest.file_path)
  return file_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcDecryptFileRequest::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CbcDecryptFileRequest.file_path)
}
inline void CbcDecryptFileRequest::set_file_path(const char* value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CbcDecryptFileRequest.file_path)
}
inline void CbcDecryptFileRequest::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CbcDecryptFileRequest.file_path)
}
inline ::std::string* CbcDecryptFileRequest::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CbcDecryptFileRequest.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CbcDecryptFileRequest::release_file_path() {
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CbcDecryptFileRequest::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:crypto.CbcDecryptFileRequest.file_path)
}

// -------------------------------------------------------------------

// CbcDecryptFileResponse

// -------------------------------------------------------------------

// CreateKeyPairRequest

// optional .crypto.AsymmetricType type = 1;
inline void CreateKeyPairRequest::clear_type() {
  type_ = 0;
}
inline ::crypto::AsymmetricType CreateKeyPairRequest::type() const {
  // @@protoc_insertion_point(field_get:crypto.CreateKeyPairRequest.type)
  return static_cast< ::crypto::AsymmetricType >(type_);
}
inline void CreateKeyPairRequest::set_type(::crypto::AsymmetricType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:crypto.CreateKeyPairRequest.type)
}

// optional .crypto.AsymmetricKeyBits key_bits = 2;
inline void CreateKeyPairRequest::clear_key_bits() {
  key_bits_ = 0;
}
inline ::crypto::AsymmetricKeyBits CreateKeyPairRequest::key_bits() const {
  // @@protoc_insertion_point(field_get:crypto.CreateKeyPairRequest.key_bits)
  return static_cast< ::crypto::AsymmetricKeyBits >(key_bits_);
}
inline void CreateKeyPairRequest::set_key_bits(::crypto::AsymmetricKeyBits value) {
  
  key_bits_ = value;
  // @@protoc_insertion_point(field_set:crypto.CreateKeyPairRequest.key_bits)
}

// -------------------------------------------------------------------

// CreateKeyPairResponse

// optional string public_key = 2;
inline void CreateKeyPairResponse::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateKeyPairResponse::public_key() const {
  // @@protoc_insertion_point(field_get:crypto.CreateKeyPairResponse.public_key)
  return public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateKeyPairResponse::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CreateKeyPairResponse.public_key)
}
inline void CreateKeyPairResponse::set_public_key(const char* value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CreateKeyPairResponse.public_key)
}
inline void CreateKeyPairResponse::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CreateKeyPairResponse.public_key)
}
inline ::std::string* CreateKeyPairResponse::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CreateKeyPairResponse.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateKeyPairResponse::release_public_key() {
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateKeyPairResponse::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:crypto.CreateKeyPairResponse.public_key)
}

// optional string private_key = 3;
inline void CreateKeyPairResponse::clear_private_key() {
  private_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateKeyPairResponse::private_key() const {
  // @@protoc_insertion_point(field_get:crypto.CreateKeyPairResponse.private_key)
  return private_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateKeyPairResponse::set_private_key(const ::std::string& value) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.CreateKeyPairResponse.private_key)
}
inline void CreateKeyPairResponse::set_private_key(const char* value) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.CreateKeyPairResponse.private_key)
}
inline void CreateKeyPairResponse::set_private_key(const char* value, size_t size) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.CreateKeyPairResponse.private_key)
}
inline ::std::string* CreateKeyPairResponse::mutable_private_key() {
  
  // @@protoc_insertion_point(field_mutable:crypto.CreateKeyPairResponse.private_key)
  return private_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateKeyPairResponse::release_private_key() {
  
  return private_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateKeyPairResponse::set_allocated_private_key(::std::string* private_key) {
  if (private_key != NULL) {
    
  } else {
    
  }
  private_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), private_key);
  // @@protoc_insertion_point(field_set_allocated:crypto.CreateKeyPairResponse.private_key)
}

// -------------------------------------------------------------------

// PublicKeyEncryptRequest

// optional .crypto.AsymmetricType type = 1;
inline void PublicKeyEncryptRequest::clear_type() {
  type_ = 0;
}
inline ::crypto::AsymmetricType PublicKeyEncryptRequest::type() const {
  // @@protoc_insertion_point(field_get:crypto.PublicKeyEncryptRequest.type)
  return static_cast< ::crypto::AsymmetricType >(type_);
}
inline void PublicKeyEncryptRequest::set_type(::crypto::AsymmetricType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:crypto.PublicKeyEncryptRequest.type)
}

// optional string public_key = 2;
inline void PublicKeyEncryptRequest::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicKeyEncryptRequest::public_key() const {
  // @@protoc_insertion_point(field_get:crypto.PublicKeyEncryptRequest.public_key)
  return public_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyEncryptRequest::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.PublicKeyEncryptRequest.public_key)
}
inline void PublicKeyEncryptRequest::set_public_key(const char* value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.PublicKeyEncryptRequest.public_key)
}
inline void PublicKeyEncryptRequest::set_public_key(const char* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.PublicKeyEncryptRequest.public_key)
}
inline ::std::string* PublicKeyEncryptRequest::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:crypto.PublicKeyEncryptRequest.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKeyEncryptRequest::release_public_key() {
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyEncryptRequest::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:crypto.PublicKeyEncryptRequest.public_key)
}

// optional string plaintext = 3;
inline void PublicKeyEncryptRequest::clear_plaintext() {
  plaintext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicKeyEncryptRequest::plaintext() const {
  // @@protoc_insertion_point(field_get:crypto.PublicKeyEncryptRequest.plaintext)
  return plaintext_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyEncryptRequest::set_plaintext(const ::std::string& value) {
  
  plaintext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.PublicKeyEncryptRequest.plaintext)
}
inline void PublicKeyEncryptRequest::set_plaintext(const char* value) {
  
  plaintext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.PublicKeyEncryptRequest.plaintext)
}
inline void PublicKeyEncryptRequest::set_plaintext(const char* value, size_t size) {
  
  plaintext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.PublicKeyEncryptRequest.plaintext)
}
inline ::std::string* PublicKeyEncryptRequest::mutable_plaintext() {
  
  // @@protoc_insertion_point(field_mutable:crypto.PublicKeyEncryptRequest.plaintext)
  return plaintext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKeyEncryptRequest::release_plaintext() {
  
  return plaintext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyEncryptRequest::set_allocated_plaintext(::std::string* plaintext) {
  if (plaintext != NULL) {
    
  } else {
    
  }
  plaintext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plaintext);
  // @@protoc_insertion_point(field_set_allocated:crypto.PublicKeyEncryptRequest.plaintext)
}

// -------------------------------------------------------------------

// PublicKeyEncryptResponse

// optional string cipher = 2;
inline void PublicKeyEncryptResponse::clear_cipher() {
  cipher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PublicKeyEncryptResponse::cipher() const {
  // @@protoc_insertion_point(field_get:crypto.PublicKeyEncryptResponse.cipher)
  return cipher_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyEncryptResponse::set_cipher(const ::std::string& value) {
  
  cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.PublicKeyEncryptResponse.cipher)
}
inline void PublicKeyEncryptResponse::set_cipher(const char* value) {
  
  cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.PublicKeyEncryptResponse.cipher)
}
inline void PublicKeyEncryptResponse::set_cipher(const char* value, size_t size) {
  
  cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.PublicKeyEncryptResponse.cipher)
}
inline ::std::string* PublicKeyEncryptResponse::mutable_cipher() {
  
  // @@protoc_insertion_point(field_mutable:crypto.PublicKeyEncryptResponse.cipher)
  return cipher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PublicKeyEncryptResponse::release_cipher() {
  
  return cipher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PublicKeyEncryptResponse::set_allocated_cipher(::std::string* cipher) {
  if (cipher != NULL) {
    
  } else {
    
  }
  cipher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cipher);
  // @@protoc_insertion_point(field_set_allocated:crypto.PublicKeyEncryptResponse.cipher)
}

// -------------------------------------------------------------------

// PrivateKeyDecryptRequest

// optional .crypto.AsymmetricType type = 1;
inline void PrivateKeyDecryptRequest::clear_type() {
  type_ = 0;
}
inline ::crypto::AsymmetricType PrivateKeyDecryptRequest::type() const {
  // @@protoc_insertion_point(field_get:crypto.PrivateKeyDecryptRequest.type)
  return static_cast< ::crypto::AsymmetricType >(type_);
}
inline void PrivateKeyDecryptRequest::set_type(::crypto::AsymmetricType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:crypto.PrivateKeyDecryptRequest.type)
}

// optional string private_key = 2;
inline void PrivateKeyDecryptRequest::clear_private_key() {
  private_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateKeyDecryptRequest::private_key() const {
  // @@protoc_insertion_point(field_get:crypto.PrivateKeyDecryptRequest.private_key)
  return private_key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKeyDecryptRequest::set_private_key(const ::std::string& value) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.PrivateKeyDecryptRequest.private_key)
}
inline void PrivateKeyDecryptRequest::set_private_key(const char* value) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.PrivateKeyDecryptRequest.private_key)
}
inline void PrivateKeyDecryptRequest::set_private_key(const char* value, size_t size) {
  
  private_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.PrivateKeyDecryptRequest.private_key)
}
inline ::std::string* PrivateKeyDecryptRequest::mutable_private_key() {
  
  // @@protoc_insertion_point(field_mutable:crypto.PrivateKeyDecryptRequest.private_key)
  return private_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateKeyDecryptRequest::release_private_key() {
  
  return private_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKeyDecryptRequest::set_allocated_private_key(::std::string* private_key) {
  if (private_key != NULL) {
    
  } else {
    
  }
  private_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), private_key);
  // @@protoc_insertion_point(field_set_allocated:crypto.PrivateKeyDecryptRequest.private_key)
}

// optional string cipher = 3;
inline void PrivateKeyDecryptRequest::clear_cipher() {
  cipher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateKeyDecryptRequest::cipher() const {
  // @@protoc_insertion_point(field_get:crypto.PrivateKeyDecryptRequest.cipher)
  return cipher_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKeyDecryptRequest::set_cipher(const ::std::string& value) {
  
  cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.PrivateKeyDecryptRequest.cipher)
}
inline void PrivateKeyDecryptRequest::set_cipher(const char* value) {
  
  cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.PrivateKeyDecryptRequest.cipher)
}
inline void PrivateKeyDecryptRequest::set_cipher(const char* value, size_t size) {
  
  cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.PrivateKeyDecryptRequest.cipher)
}
inline ::std::string* PrivateKeyDecryptRequest::mutable_cipher() {
  
  // @@protoc_insertion_point(field_mutable:crypto.PrivateKeyDecryptRequest.cipher)
  return cipher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateKeyDecryptRequest::release_cipher() {
  
  return cipher_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKeyDecryptRequest::set_allocated_cipher(::std::string* cipher) {
  if (cipher != NULL) {
    
  } else {
    
  }
  cipher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cipher);
  // @@protoc_insertion_point(field_set_allocated:crypto.PrivateKeyDecryptRequest.cipher)
}

// -------------------------------------------------------------------

// PrivateKeyDecryptResponse

// optional string plaintext = 2;
inline void PrivateKeyDecryptResponse::clear_plaintext() {
  plaintext_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PrivateKeyDecryptResponse::plaintext() const {
  // @@protoc_insertion_point(field_get:crypto.PrivateKeyDecryptResponse.plaintext)
  return plaintext_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKeyDecryptResponse::set_plaintext(const ::std::string& value) {
  
  plaintext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:crypto.PrivateKeyDecryptResponse.plaintext)
}
inline void PrivateKeyDecryptResponse::set_plaintext(const char* value) {
  
  plaintext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:crypto.PrivateKeyDecryptResponse.plaintext)
}
inline void PrivateKeyDecryptResponse::set_plaintext(const char* value, size_t size) {
  
  plaintext_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:crypto.PrivateKeyDecryptResponse.plaintext)
}
inline ::std::string* PrivateKeyDecryptResponse::mutable_plaintext() {
  
  // @@protoc_insertion_point(field_mutable:crypto.PrivateKeyDecryptResponse.plaintext)
  return plaintext_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PrivateKeyDecryptResponse::release_plaintext() {
  
  return plaintext_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PrivateKeyDecryptResponse::set_allocated_plaintext(::std::string* plaintext) {
  if (plaintext != NULL) {
    
  } else {
    
  }
  plaintext_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plaintext);
  // @@protoc_insertion_point(field_set_allocated:crypto.PrivateKeyDecryptResponse.plaintext)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace crypto

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::crypto::SymmetricKeyBits> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::crypto::SymmetricKeyBits>() {
  return ::crypto::SymmetricKeyBits_descriptor();
}
template <> struct is_proto_enum< ::crypto::AsymmetricType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::crypto::AsymmetricType>() {
  return ::crypto::AsymmetricType_descriptor();
}
template <> struct is_proto_enum< ::crypto::AsymmetricKeyBits> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::crypto::AsymmetricKeyBits>() {
  return ::crypto::AsymmetricKeyBits_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_crypto_5fserver_2eproto__INCLUDED
